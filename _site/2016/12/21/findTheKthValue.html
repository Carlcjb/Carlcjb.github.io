<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>两个已排序的数组求中间值(寻找k小值算法) | Dailc的个人主页</title>
    <meta name="author" content="dailc" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="Everything about dailc" />
    <meta name="baidu-site-verification" content="cVrw8PsZv7" />
    <meta name="keywords" content="dailc,戴荔春,戴荔春的博客,dailc的博客" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  	<link href="/asserts/css/default.css" rel="stylesheet" type="text/css" media="all">
	<script type="text/javascript" src="/asserts/js/app.js" ></script> 
</head>
<body>
	<!--头部 -->
	<header class="header">
		<div class="header-container">
			<section class="site-logo">
				<a  href="/">撒网要见鱼</a>
			</section>
			<button class="collapsed " type="button" >
		        <span class="icon-bar"></span>
		        <span class="icon-bar"></span>
		        <span class="icon-bar"></span>
		    </button>
		    <div class="menu-container">
				<nav class="site-nav">
					<ul>
						<li>
							<a  href="/blog/archiveAll.html">随笔</a>
						</li>
						<li>
							<a  href="/blog/archive.html">博客</a>
						</li>
						<li>
							<a  href="/blog/categories.html">分类</a>
						</li>
						<li>
							<a  href="/blog/tags.html">标签</a>
						</li>
						<li>
							<a  href="/demo/demo.html">Demo</a>
						</li>
						<li>
							<a  href="/favour/music.html">音乐</a>
						</li>
						<li>
							<a  href="/favour/book.html">Book</a>
						</li>
						<li>
							<a  href="/about/timeline.html">时间轴</a>
						</li>
						<li>
							<a  href="/others/collection.html">收藏</a>
						</li>
						<li>
							<a  href="/about/about.html">关于</a>
						</li>
					</ul>
				</nav>
				<div class="site-search">
					<input type="text" />
				</div>
			</div>
		</div>
	</header>
	<link href="/asserts/css/blog_article_post.css" rel="stylesheet" type="text/css" media="all">
<link href="/asserts/css/blog_personCard_style.css" rel="stylesheet" type="text/css" media="all">
<link href="/asserts/css/imageBubble.css" rel="stylesheet" type="text/css" media="all">
	
	<div class="wrap">
		<div class="container">
			<!-- 左侧，内容，多说评论等-->
			<div class="col-md-9">
				<!-- 内容-->
				<div class="markdown-body">
					<!--标题区域 -->
					<div class="title-container">
					<h1 class="page-title"><a  title="两个已排序的数组求中间值(寻找k小值算法)">两个已排序的数组求中间值(寻找k小值算法)</a> </h1>
						<!-- metainfo-->
						<section class="meta clearfix">
<span class="time">
<time datetime="2016-12-21">2016-12-21</time>
</span>

| 
<span class="categories">
	分类
	    
	    <a href="/blog/categories.html#blog" title="blog">blog</a>&nbsp;
	    
</span>


| 
<span class="tags">
	标签
		
		<a href="/blog/tags.html#javascript" title="javascript">javascript</a>&nbsp;
		
		<a href="/blog/tags.html#算法" title="算法">算法</a>&nbsp;
		
		<a href="/blog/tags.html#寻找k小值" title="寻找k小值">寻找k小值</a>&nbsp;
		
		<a href="/blog/tags.html#leetcode" title="leetcode">leetcode</a>&nbsp;
		
</span>

| 
<span class="views">
	浏览
	<a id="busuanzi_value_page_pv"></a>&nbsp;
</span>
</section>
						<section class="right-tips">
							<span >
								寻找k小值
							</span>
						</section>
					</div>
					<!-- 特别推荐-->
					
					<!-- 内容区域-->
					<div class="content-container">
						 <h2 id="起由">起由</h2>
<p>这是leetcode上的一道经典题目，最近正好准备重新补下基础，于是研究了下这个算法。</p>

<h2 id="需求描述">需求描述</h2>
<p>有序数组(升序)，X(M个数)和Y(N个数)，数组合并后为Z(L个数)，求两个数组合并后的Z数组的中间值，比如</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[1,2,3,4] 
的中间值是(2+3)/2=2.5
[1,2,3] 
的中间值是2
</code></pre>
</div>

<h2 id="算法步骤">算法步骤</h2>

<h3 id="前提分析">前提分析</h3>
<p>数组求中位数有两种情况(以下第×位数从1开始算起)</p>

<ul>
  <li>
    <p>若合并后<code class="highlighter-rouge">L</code>为偶数，那么中间数为<code class="highlighter-rouge">第L/2位数和第(L/2+1)位数的平均值</code>
   其中L/2后取整</p>
  </li>
  <li>
    <p>若合并后为奇数，那么中间数为     <code class="highlighter-rouge">第(L/2+1)位数</code></p>
  </li>
</ul>

<p>所以，以上找中间数问题就转变成了在两个已排序数组中找第k大的数(第k小值)</p>

<h3 id="解决思路假设是理想状态下">解决思路(假设是理想状态下)</h3>

<ul>
  <li>每次分别在X数组中和Y数组中取k/2个值进行比较(加起来正好k个)，下述为了方便，将<code class="highlighter-rouge">k/2-1</code>用<code class="highlighter-rouge">middle</code>表示</li>
  <li>比较<code class="highlighter-rouge">X[middle]</code>和<code class="highlighter-rouge">Y[middle]</code>
    <ul>
      <li>
        <p>如果<code class="highlighter-rouge">X[middle]&lt;Y[middle]</code>，意味着<code class="highlighter-rouge">第k位数&gt;=Y[middle]&gt;X[middle]</code>，
  所以X[middle]和之前的数肯定不会数第k位数，那么我们可以抛弃X数组中middle以及前面部分，</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>  X=X.slice(middle),Y=Y,k=k-middle;
</code></pre>
        </div>
        <p>重新进行第一步比较</p>
      </li>
      <li>
        <p>如果<code class="highlighter-rouge">X[middle]&gt;Y[middle]</code>，意味着<code class="highlighter-rouge">第k位数&gt;=X[middle]&gt;Y[middle]</code>，
  那么我们可以抛弃Y数组中middle以及前面部分，</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>  X=X,Y=Y.slice(middle),k=k-middle;
</code></pre>
        </div>
        <p>重新进行第一步比较</p>
      </li>
      <li>
        <p>如果<code class="highlighter-rouge">X[middle]==Y[middle]</code>，意味着X和Y中正在比较的k位数全部&lt;=第k个数。
  所以第k个数就在正在比较的数之中，而因为数组是升序，所以不是<code class="highlighter-rouge">X[middle]</code>，就是<code class="highlighter-rouge">Y[middle]</code>
  我们只需要取最终的值为<code class="highlighter-rouge">X[middle]</code>即可</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="实现步骤以下数组是从0开始算起的考虑到一些可能的实际情况找数组中第k大的数">实现步骤(以下数组是从0开始算起的)，考虑到一些可能的实际情况，找数组中第K大的数</h3>

<ul>
  <li>
    <p>第一步，我们交换两个数组的位置，确保X大小小于等于Y(如果X已经大于Y，则交换两个数组)</p>
  </li>
  <li>
    <p>第二步，如果X数组为0，那么第k位数肯定在Y中，并且值就是<code class="highlighter-rouge">Y[k-1]</code></p>
  </li>
  <li>
    <p>第三步，如果k为1，那么只需要取<code class="highlighter-rouge">Math.min(X[0],Y[0])</code>，因为第一位数只可能是两个数组中的首位中的最小的一个</p>
  </li>
  <li>
    <p>第四步，如果k不满足以上特殊值，则分别比较X数组和Y数组中特定的值</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  var partA = ~~Math.min(k/2,m),partB = k - partA;
  //这时候X中需要比较的值的分布可能为下述情况(当k/2为1时，则只有一个partA)
  0,...,partA-1
  //Y中需要比较的值得分布可能为
  0,...,partB-1
  //而且X中需要比较的数和Y中需要比较的数加起来刚好有k位，而且(第k位数&gt;=X[partA-1],第k位数&gt;=X[partB-1])
</code></pre>
    </div>

    <ul>
      <li>
        <p>如果<code class="highlighter-rouge">X[partA-1]&lt;Y[partB-1]</code>，(原理上述已经分析)</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>  X=X.slice(partA),Y=Y,k=k-partA;
</code></pre>
        </div>
        <p>重新进行第一步比较</p>
      </li>
      <li>
        <p>如果<code class="highlighter-rouge">X[partA-1]&gt;Y[partB-1]</code>，(原理上述已经分析)</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>  X=X,Y=Y.slice(partB),k=k-partB;
</code></pre>
        </div>
        <p>重新进行第一步比较</p>
      </li>
      <li>
        <p>如果<code class="highlighter-rouge">X[partA-1]==Y[partB-1]</code>，(原理上述已经分析)
  取最终的值为<code class="highlighter-rouge">X[partA-1]</code></p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="算法复杂度">算法复杂度</h2>

<h3 id="空间复杂度">空间复杂度</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>O(1)
</code></pre>
</div>
<p>这个算法没有额外的空间要求</p>

<h3 id="时间复杂度">时间复杂度</h3>
<p>这个算法每次分别去掉某一个数组中的某一部分，假设X数组长度为，Y数组长度为N。
那么复杂度计算方式为:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>0(lgM+lg(N))=O(lgMN)&lt;=O(2lg(M+N)) = O(lg(M+N))
</code></pre>
</div>

<h2 id="算法实例">算法实例</h2>
<p>以下按照上述算法实现步骤，基于一个实例进行分析。</p>

<h3 id="前提">前提</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>X=[1,3,5];
Y=[1,2,3,4];
</code></pre>
</div>
<p>求X和Y的中间值</p>

<h3 id="准备工作">准备工作</h3>
<p>可知，初始化时X中有3位，Y中有4为，所以一共7位，为奇数。
那么我们所求是第<code class="highlighter-rouge">4=(3+4)/2+1</code>位数</p>

<h3 id="实现过程">实现过程</h3>

<ul>
  <li>
    <p>第一步，X长度小于Y，不需要交换，其中X数组的长度m为3，Y数组的长度n为4，k为4</p>
  </li>
  <li>
    <p>第二步，取特殊值进行比较</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  var partA = ~~Math.min(k/2,m);//2
  var partB = k - partA; //2
</code></pre>
    </div>
  </li>
  <li>
    <p>第三步，比较<code class="highlighter-rouge">X[partA-1]</code>和<code class="highlighter-rouge">Y[partB-1]</code>，结果是<code class="highlighter-rouge">X[1]&gt;Y[1]</code>，
  所以舍弃Y中部分值，重新进行比较</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  X=X,Y=Y.slice(partB),k=k-partB;
</code></pre>
    </div>
    <p>舍弃完毕后，X为<code class="highlighter-rouge">1,3,5</code>，Y为<code class="highlighter-rouge">3,4</code>，k为2
  之后交换X和为，X换为<code class="highlighter-rouge">3,4</code>，m为2，Y换位<code class="highlighter-rouge">1,3,5</code>，n为3</p>
  </li>
  <li>
    <p>第四步，重新去特殊值进行比较</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  var partA = ~~Math.min(k/2,m);//1
  var partB = k - partA; //1
</code></pre>
    </div>
  </li>
  <li>
    <p>第五步，比较<code class="highlighter-rouge">X[partA-1]</code>和<code class="highlighter-rouge">Y[partB-1]</code>，结果是<code class="highlighter-rouge">X[0]&gt;Y[0]</code>，
  所以舍弃Y中部分值，重新进行比较</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  X=X,Y=Y.slice(partB),k=k-partB;
</code></pre>
    </div>
    <p>舍弃完毕后，X为<code class="highlighter-rouge">3,4</code>，Y为<code class="highlighter-rouge">3,5</code>，k为1
  不需要交换x与Y，此时m为2，n为2</p>
  </li>
  <li>
    <p>第六步，重新比较新的数组，由于符合条件<code class="highlighter-rouge">k==1</code>，所以</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  第k个值 = Math.min(X[0],Y[0]); //3
</code></pre>
    </div>
    <p>至此，整个算法流程运行完毕，最终的中间值为<code class="highlighter-rouge">3</code></p>
  </li>
</ul>

<h3 id="图示">图示</h3>
<p><img src="https://dailc.github.io/leetcode/algorithms/Median-of-Two-Sorted-Arrays/img_leetcode_medianOfTwoSortedArrays.png" alt="" /></p>

<h2 id="实现代码示例">实现代码示例</h2>
<p>以下是相应算法的代码实现</p>

<h3 id="js代码实现">JS代码实现</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>function findMedianSortedArrays2(nums1,nums2) {
		var m = nums1.length,n = nums2.length;
		var total = m+n;
		
		//找到两个排序数组中的第k个小数，内部假设m小于n
		var findKth = function(X,Y,m,n,k){
			if(m&gt;n){
				//颠倒mn的顺序
				return findKth(Y,X,n,m,k);
			} else if(m===0){
				//如果X数组为空，那么K肯定就在Y数组中
				return Y[k-1];
			} else if(k===1){
				//只有一位，由于是升序，所以必然是X[0]或Y[0]
				return Math.min(X[0],Y[0]);
			}
			
			//divide k into two parts,最小为1
			//可以肯定得是partA和partB都&lt;=K
			var partA = ~~Math.min(k/2,m),partB = k - partA;
			//第一位数其实是X[0]，因为程序从0开始
			//以下判断时关键，每一次都可以去掉不符合要求的一部分，进行精简
			if(X[partA-1] &lt; Y[partB-1]){
				return findKth(X.slice(partA),Y,m-partA,n,k-partA);
			} else if(X[partA-1] &gt; Y[partB-1]) {
				return findKth(X,Y.slice(partB),m,n-partB,k-partB);
			} else {
				//如果X数组中的第partA位和Y数组中的第partB为相等
				//由于X中有1,...,partA
				//Y中有1,...,partB
				//两者加起来刚好为k,而不管k在X中还是Y中，都必须满足X[k]&gt;=X[partA]=X[partB]
				//所以k只可能是partA或partB(原因是X和Y中加起来已经有K个数小于等于X[k]了，所以K只能在这里面)
				return X[partA-1];
			}
		};
		
		if(total%2!==0){
			 return findKth(nums1, nums2, m,n, ~~(total / 2)+1);  
		} else {
			return (findKth(nums1, nums2, m,n, ~~(total / 2)+1 )+findKth(nums1, nums2, m,n, ~~(total / 2 )))/2;  
		}
	};
</code></pre>
</div>

<h2 id="算法横向比较">算法横向比较</h2>
<p>上述描述的算法是寻找k小值算法，但其实寻找中间数还有其它方案</p>

<ul>
  <li>比如两个数组合并后，在排序，在找中间值。</li>
</ul>

<p>这种方案的特点是简单，但是复杂度要远远大于寻找k小值算法，以下是在数组长度分别为3000和500000时，两者性能对比。</p>

<p><img src="https://dailc.github.io/jsPerformanceAnalysis/staticresource/performanceAnalysis/leetcode/medianOfTwoSortedArray/demo_js_performanceAnalysis_leetcode_medianOfTwoSortedArray_1.png" alt="" /></p>

<p><img src="https://dailc.github.io/jsPerformanceAnalysis/staticresource/performanceAnalysis/leetcode/medianOfTwoSortedArray/demo_js_performanceAnalysis_leetcode_medianOfTwoSortedArray_2.png" alt="" /></p>

<h2 id="源码">源码</h2>
<p><a href="https://github.com/dailc/leetcode/tree/master/algorithms/Median-of-Two-Sorted-Arrays">https://github.com/dailc/leetcode/tree/master/algorithms/Median-of-Two-Sorted-Arrays</a></p>

<h3 id="性能分析页面地址">性能分析页面地址</h3>
<p><a href="https://dailc.github.io/jsPerformanceAnalysis/html/performanceAnalysis/leetcode/demo_performanceAnalysis_leetcode_medianOfTwoSortedArrays.html">两个排序数组求中间值性能分析</a></p>

<h2 id="原文地址">原文地址</h2>
<p>原文在我个人博客上面</p>

<p><a href="https://dailc.github.io/2016/12/21/findTheKthValue.html">两个已排序的数组求中间值(寻找k小值算法)</a></p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li>
    <p><a href="http://blog.csdn.net/zxzxy1988/article/details/8587244">Leetcode 4 Median of Two Sorted Arrays</a></p>
  </li>
  <li>
    <p><a href="http://blog.csdn.net/yutianzuijin/article/details/11499917/">leetcode之 median of two sorted arrays</a></p>
  </li>
</ul>

					</div>
					<!-- 上一篇与下一篇-->
					<section align="right" class="post-next-prev">
					  <span>
					    <a  href="/2016/12/17/bookReview_senseAndSensibility.html" class="active"  >上一篇</a>
					    &nbsp;&nbsp;&nbsp;
					    <a  href="/2016/12/25/annualReport.html" class="active"  >下一篇</a>
					  </span>
					</section>
				</div>
				<!-- 多说-->
				
<!--多说评论 -->
<div id="duoshuo-container">
<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="http://localhost:4000/2016/12/21/findTheKthValue.html}" data-title="两个已排序的数组求中间值(寻找k小值算法)" data-url="http://localhost:4000/2016/12/21/findTheKthValue.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"dailc"};
(function() {
	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0] 
	 || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- 多说公共JS代码 end -->
</div>

				
				
			</div>
			
			<!-- 右侧包括个人介绍，TOC菜单-->
			<div class="col-md-3">
				<!-- 右侧人物面板-->
				<div class="effect1 person-card">
					
				 	<a  class="member-image">
				 			<img src="/asserts/images/img_avatar.jpg" alt="Lichun Dai"/>
				 	</a>
				 	<div class="member-info">
				 		<p class="info-name">
				 		<a >
				 			Lichun Dai
				 		</a>
				 		</p>
				 		<p>
				 			单线程生物，无法同时专注于多件事情。做自己感兴趣的工作，目前偏爱前端。业余爱好:口琴、吉他。
				 		</p>
				 	<p class="info-foot">
				 		<a class="left-card left" href="/blog/archive.html">
				 			<em>
				 				博客
				 			</em>
				 			<strong>
				 				28
				 				
				 			</strong>
				 		</a>
				 		<a class="middle-card left" href="/demo/demo.html">
				 			<em>
				 				项目
				 			</em>
				 			<strong>
				 				2
				 			</strong>
				 		</a>
				 		<a class="right-card left" href="/blog/archiveAll.html">
				 			<em>
				 				随笔
				 			</em>
				 			<strong>
				 				58
				 			</strong>
				 		</a>
				 	</p>
				 	<p class="info-social-touch">
				 		<a target="_blank" href="https://github.com/dailc" ><img src="/asserts/images/icons/favicon_github.ico" alt="GitHub"/> </a>
						<a target="_blank" href="http://5sing.kugou.com/54188866/default.html"><img src="/asserts/images/icons/favicon_5sing.ico" alt="5sing" /> </a>	
						<a target="_blank" href="http://changba.com/u/200945262"><img src="/asserts/images/icons/favicon_changba.ico" alt="唱吧" /> </a>
						<a target="_blank" href="https://www.zhihu.com/people/dailichun"><img src="/asserts/images/icons/favicon_zhihu.ico" alt="知乎" /> </a>
						<a target="_blank" href="http://www.jianshu.com/u/c104d2a4baec"><img src="/asserts/images/icons/favicon_jianshu.ico" alt="简书" /> </a>
				 	</p>
				 	</div>
				</div>

				 <!-- TOC动态菜单-->
				  <div class="slideNavContainer">     
				</div> 				
					
			</div> 
 
		</div>
	</div>
		
<script type="text/javascript" src="/asserts/js/post.js" ></script>
<script type="text/javascript" src="/asserts/js/imageBubble.js" ></script>
<script>
	ImageBubble.init('.container img');
</script>
	
	<!-- 脚步,包括版权声明，访问次数等-->
	<footer class="footer">
	    <p class="copyright">
	    	<small>
	            <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank" title="许可协议">©</a> 2016&nbsp;&nbsp;&nbsp;&nbsp;<a href="/about/">Lichun Dai</a>
	        </small>
	    </p>
	    <p class="more-tips">
	    	<span>Powered by Jekyll</span>&nbsp;&nbsp;&nbsp;&nbsp;
	    	<span id="busuanzi_container_site_pv">总访客<span id="busuanzi_value_site_uv" class="site-uv"></span>人</span>&nbsp;&nbsp;&nbsp;&nbsp;
	    	<span id="busuanzi_container_site_pv">总访问<span id="busuanzi_value_site_pv" class="site-pv"></span>次</span>
	    </p>  
	</footer>

<script>
//百度统计
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cf8506e0ef223e57ff6239944e5d46a4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<!--不蒜子 -->
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



</body>
</html>
