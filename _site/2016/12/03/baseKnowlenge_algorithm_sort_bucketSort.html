<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>排序算法之桶排序的深入理解以及性能分析 | Dailc的个人主页</title>
    <meta name="author" content="dailc" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="Everything about dailc" />
    <meta name="baidu-site-verification" content="cVrw8PsZv7" />
    <meta name="keywords" content="dailc,戴荔春,戴荔春的博客,dailc的博客" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  	<link href="/asserts/css/default.css" rel="stylesheet" type="text/css" media="all">
	<script type="text/javascript" src="/asserts/js/app.js" ></script> 
</head>
<body>
	<!--头部 -->
	<header class="header">
		<div class="header-container">
			<section class="site-logo">
				<a  href="/">撒网要见鱼</a>
			</section>
			<button class="collapsed " type="button" >
		        <span class="icon-bar"></span>
		        <span class="icon-bar"></span>
		        <span class="icon-bar"></span>
		    </button>
		    <div class="menu-container">
				<nav class="site-nav">
					<ul>
						<li>
							<a  href="/blog/archiveAll.html">随笔</a>
						</li>
						<li>
							<a  href="/blog/archive.html">博客</a>
						</li>
						<li>
							<a  href="/blog/categories.html">分类</a>
						</li>
						<li>
							<a  href="/blog/tags.html">标签</a>
						</li>
						<li>
							<a  href="/demo/demo.html">Demo</a>
						</li>
						<li>
							<a  href="/favour/music.html">音乐</a>
						</li>
						<li>
							<a  href="/favour/book.html">Book</a>
						</li>
						<li>
							<a  href="/about/timeline.html">时间轴</a>
						</li>
						<li>
							<a  href="/others/collection.html">收藏</a>
						</li>
						<li>
							<a  href="/about/about.html">关于</a>
						</li>
					</ul>
				</nav>
				<div class="site-search">
					<input type="text" />
				</div>
			</div>
		</div>
	</header>
	<link href="/asserts/css/blog_article_post.css" rel="stylesheet" type="text/css" media="all">
<link href="/asserts/css/blog_personCard_style.css" rel="stylesheet" type="text/css" media="all">
<link href="/asserts/css/imageBubble.css" rel="stylesheet" type="text/css" media="all">
	
	<div class="wrap">
		<div class="container">
			<!-- 左侧，内容，多说评论等-->
			<div class="col-md-9">
				<!-- 内容-->
				<div class="markdown-body">
					<!--标题区域 -->
					<div class="title-container">
					<h1 class="page-title"><a  title="排序算法之桶排序的深入理解以及性能分析">排序算法之桶排序的深入理解以及性能分析</a> </h1>
						<!-- metainfo-->
						<section class="meta clearfix">
<span class="time">
<time datetime="2016-12-03">2016-12-03</time>
</span>

| 
<span class="categories">
	分类
	    
	    <a href="/blog/categories.html#blog" title="blog">blog</a>&nbsp;
	    
</span>


| 
<span class="tags">
	标签
		
		<a href="/blog/tags.html#javascript" title="javascript">javascript</a>&nbsp;
		
		<a href="/blog/tags.html#算法" title="算法">算法</a>&nbsp;
		
		<a href="/blog/tags.html#排序算法" title="排序算法">排序算法</a>&nbsp;
		
		<a href="/blog/tags.html#桶排序" title="桶排序">桶排序</a>&nbsp;
		
		<a href="/blog/tags.html#bucketSort" title="bucketSort">bucketSort</a>&nbsp;
		
		<a href="/blog/tags.html#基础知识" title="基础知识">基础知识</a>&nbsp;
		
		<a href="/blog/tags.html#性能分析" title="性能分析">性能分析</a>&nbsp;
		
</span>

| 
<span class="views">
	浏览
	<a id="busuanzi_value_page_pv"></a>&nbsp;
</span>
</section>
						<section class="right-tips">
							<span >
								桶排序
							</span>
						</section>
					</div>
					<!-- 特别推荐-->
					
					<!-- 内容区域-->
					<div class="content-container">
						 <h2 id="前言">前言</h2>
<p>本文为算法分析系列博文之一，深入探究桶排序，分析各自环境下的性能，同时辅以性能分析示例加以佐证</p>

<h2 id="实现思路与步骤">实现思路与步骤</h2>

<h3 id="思路">思路</h3>

<ol>
  <li>设置固定空桶数</li>
  <li>将数据放到对应的空桶中</li>
  <li>将每个不为空的桶进行排序</li>
  <li>拼接不为空的桶中的数据，得到结果</li>
</ol>

<h3 id="步骤演示">步骤演示</h3>
<p>假设一组数据(20长度)为</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[63,157,189,51,101,47,141,121,157,156,194,117,98,139,67,133,181,13,28,109] 
</code></pre>
</div>
<p>现在需要按5个分桶，进行桶排序，实现步骤如下:</p>

<ol>
  <li>
    <p>找到数组中的最大值194和最小值13，然后根据桶数为5，计算出每个桶中的数据范围为<code class="highlighter-rouge">(194-13+1)/5=36.4</code></p>
  </li>
  <li>遍历原始数据，(以第一个数据63为例)先找到该数据对应的桶序列<code class="highlighter-rouge">Math.floor(63 - 13) / 36.4) =1</code>，然后将该数据放入序列为1的桶中(从0开始算)</li>
  <li>当向同一个序列的桶中第二次插入数据时，判断桶中已存在的数字与新插入的数字的大小，按从左到右，从小打大的顺序插入。如第一个桶已经有了63，再插入51，67后，桶中的排序为(51,63,67) <strong>一般通过链表来存放桶中数据，但js中可以使用数组来模拟</strong></li>
  <li>全部数据装桶完毕后，按序列，从小到大合并所有非空的桶(如0,1,2,3,4桶)</li>
  <li>合并完之后就是已经排完序的数据</li>
</ol>

<h3 id="步骤图示">步骤图示</h3>
<p><img src="https://dailc.github.io/jsPerformanceAnalysis/staticresource/performanceAnalysis/algorithmSort/demo_js_algorithmSort_bucketSort_1.png" alt="" /></p>

<h2 id="实现代码">实现代码</h2>
<p>以下分别以JS和Java的实现代码为例</p>

<h3 id="js实现代码数组替代链表版本">JS实现代码(数组替代链表版本)</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>var bucketSort = function(arr, bucketCount) {
    if (arr.length &lt;= 1) {
        return arr;
    }
    bucketCount = bucketCount || 10;
    //初始化桶
    var len = arr.length,
    buckets = [],
    result = [],
    max = arr[0],
    min = arr[0];
    for (var i = 1; i &lt; len; i++) {
        min = min &lt;= arr[i] ? min: arr[i];
        max = max &gt;= arr[i] ? max: arr[i];
    }
    //求出每一个桶的数值范围
    var space = (max - min + 1) / bucketCount;
    //将数值装入桶中
    for (var i = 0; i &lt; len; i++) {
        //找到相应的桶序列
        var index = Math.floor((arr[i] - min) / space);
        //判断是否桶中已经有数值
        if (buckets[index]) {
            //数组从小到大排列
            var bucket = buckets[index];
            var k = bucket.length - 1;
            while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; arr[i]) {
                buckets[index][k + 1] = buckets[index][k];
                k--
            }
            buckets[index][k + 1] = arr[i];
        } else {
            //新增数值入桶，暂时用数组模拟链表
            buckets[index] = [];
            buckets[index].push(arr[i]);
        }
    }
    //开始合并数组
    var n = 0;
    while (n &lt; bucketCount) {
        if (buckets[n]) {
            result = result.concat(buckets[n]);
        }
        n++;
    }
    return result;
};
//开始排序
arr = bucketSort(arr, self.bucketCount);
</code></pre>
</div>

<h3 id="js实现代码模拟链表实现版本">JS实现代码(模拟链表实现版本)</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>var L = require('linklist'); //链表
var sort = function(arr, bucketCount) {
	if(arr.length &lt;= 1) {
		return arr;
	}
	bucketCount = bucketCount || 10;
	//初始化桶
	var len = arr.length,
		buckets = [],
		result = [],
		max = arr[0],
		min = arr[0];
	for(var i = 1; i &lt; len; i++) {
		min = min &lt;= arr[i] ? min : arr[i];
		max = max &gt;= arr[i] ? max : arr[i];
	}
	//求出每一个桶的数值范围
	var space = (max - min + 1) / bucketCount;
	//将数值装入桶中
	for(var i = 0; i &lt; len; i++) {
		//找到相应的桶序列
		var index = Math.floor((arr[i] - min) / space);
		//判断是否桶中已经有数值
		if(buckets[index]) {
			//数组从小到大排列
			var bucket = buckets[index];
			var insert = false; //插入标石
			L.reTraversal(bucket, function(item, done) {
				if(arr[i] &lt;= item.v) { //小于，左边插入
					L.append(item, _val(arr[i]));
					insert = true;
					done(); //退出遍历
				}
			});
			if(!insert) { //大于，右边插入
				L.append(bucket, _val(arr[i]));
			}
		} else {
			var bucket = L.init();
			L.append(bucket, _val(arr[i]));
			buckets[index] = bucket; //链表实现
		}
	}
	//开始合并数组
	for(var i = 0, j = 0; i &lt; bucketCount; i++) {
		L.reTraversal(buckets[i], function(item) {
			// console.log(i+":"+item.v);
			result[j++] = item.v;
		});
	}
	return result;
};

//链表存储对象
function _val(v) {
	return {
		v: v
	}
}
//开始排序
arr = bucketSort(arr, self.bucketCount);
</code></pre>
</div>
<p>其中，linklist为引用的第三方库，地址
<a href="https://github.com/dead-horse/js-linklist">linklist</a></p>

<h3 id="java实现代码">Java实现代码</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>public static double[] bucketSort(double arr[], int bucketCount) {

    int len = arr.length;
    double[] result = new double[len];
    double min = arr[0];
    double max = arr[0];
    //找到最大值和最小值
    for (int i = 1; i &lt; len; i++) {
        min = min &lt;= arr[i] ? min: arr[i];
        max = max &gt;= arr[i] ? max: arr[i];
    }
    //求出每一个桶的数值范围
    double space = (max - min + 1) / bucketCount;
    //先创建好每一个桶的空间,这里使用了泛型数组
    ArrayList &lt; Double &gt; [] arrList = new ArrayList[bucketCount];
    //把arr中的数均匀的的分布到[0,1)上，每个桶是一个list，存放落在此桶上的元素   
    for (int i = 0; i &lt; len; i++) {
        int index = (int) Math.floor((arr[i] - min) / space);
        if (arrList[index] == null) {
            //如果链表里没有东西
            arrList[index] = new ArrayList &lt; Double &gt; ();
            arrList[index].add(arr[i]);
        } else {
            //排序
            int k = arrList[index].size() - 1;
            while (k &gt;= 0 &amp;&amp; (Double) arrList[index].get(k) &gt; arr[i]) {
                if (k + 1 &gt; arrList[index].size() - 1) {
                    arrList[index].add(arrList[index].get(k));
                } else {
                    arrList[index].set(k + 1, arrList[index].get(k));
                }
                k--;
            }
            if (k + 1 &gt; arrList[index].size() - 1) {
                arrList[index].add(arr[i]);
            } else {
                arrList[index].set(k + 1, arr[i]);
            }
        }

    }

    //把各个桶的排序结果合并  ,count是当前的数组下标
    int count = 0;

    for (int i = 0; i &lt; bucketCount; i++) {
        if (null != arrList[i] &amp;&amp; arrList[i].size() &gt; 0) {
            Iterator &lt; Double &gt; iter = arrList[i].iterator();
            while (iter.hasNext()) {
                Double d = (Double) iter.next();
                result[count] = d;
                count++;
            }
        }
    }
    return result;
}
//开始排序,其中arr为需要排序的数组
double[] result = bucketSort(arr,bucketCount);
</code></pre>
</div>

<h2 id="算法复杂度">算法复杂度</h2>
<p>算法复杂度的计算，这里我们直接抛开常数，只计算与N(数组长度)与M(分桶数)相关的语句</p>

<h3 id="时间复杂度">时间复杂度</h3>
<p>因为时间复杂度度考虑的是最坏的情况，所以桶排序的时间复杂度可以这样去看(只看主要耗时部分，而且常熟部分K一般都省去)</p>

<ul>
  <li>N次循环，每一个数据装入桶</li>
  <li>然后M次循环，每一个桶中的数据进行排序(每一个桶中有N/M个数据)，假设为使用比较先进的排序算法进行排序</li>
</ul>

<p>一般较为先进的排序算法时间复杂度是O(N*logN)，实际的桶排序执行过程中，桶中数据是以链表形式插入的，那么整个桶排序的时间复杂度为:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>O(N)+O(M*(N/M)*log(N/M))=O(N*(log(N/M)+1))
</code></pre>
</div>
<p><strong>所以，理论上来说(N个数都符合均匀分布)，当M=N时，有一个最小值为O(N)</strong></p>

<p><em>PS:这里有人提到最后还有M个桶的合并，其实首先M一般远小于N，其次再效率最高时是M=N，这是就算把这个算进去，也是O(N</em>(1+log(N/M)+M/N))，极小值还是O(2<em>N)=O(N)</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>求M的极小值，具体计算为:(其中N可以看作一个很大的常数)
F(M) = log(N/M)+M/N) = LogN-LogM+M/N
它的导函数
F'(M) = -1/M + 1/N
因为导函数大于0代表函数递增，小于0代表函数递减
所以F(M)在(0,N) 上递减
在(N,+∞)上递增
所以当M=N时取到极小值
</code></pre>
</div>

<h3 id="空间复杂度">空间复杂度</h3>
<p>空间复杂度一般指算法执行过程中需要的额外存储空间</p>

<p>桶排序中，需要创建M个桶的额外空间，以及N个元素的额外空间</p>

<p>所以桶排序的空间复杂度为 <strong>O(N+M)</strong></p>

<h3 id="稳定性">稳定性</h3>
<p>稳定性是指，比如a在b前面，a=b，排序后，a仍然应该在b前面，这样就算稳定的。</p>

<p>桶排序中，假如升序排列，a已经在桶中，b插进来是永远都会a右边的(因为一般是从右到左，如果不小于当前元素，则插入改元素的右侧)</p>

<p><strong>所以桶排序是稳定的</strong></p>

<p><em>PS:当然了，如果采用元素插入后再分别进行桶内排序，并且桶内排序算法采用快速排序，那么就不是稳定的</em></p>

<h3 id="适用范围">适用范围</h3>
<p>用排序主要适用于均匀分布的数字数组，在这种情况下能够达到最大效率</p>

<h2 id="性能分析">性能分析</h2>
<p>为了更好的测试桶排序在各自环境的性能，分别用普通JS浏览器，Node.js环境，Java环境进行测试，得出以下的对比分析</p>

<p>前提数据为:</p>

<ul>
  <li>10W长度的随机数组</li>
  <li>数组的范围为[0,10000)</li>
  <li>数据为浮点类型</li>
</ul>

<h3 id="js浏览器环境下的性能数组替代链表型">JS浏览器环境下的性能(数组替代链表型)</h3>
<p>本文主要是在webkit内核的浏览器中测试，浏览器中的方案类型为</p>

<ul>
  <li>数据插入时排序，但是使用数组替代链表</li>
</ul>

<p>出人意料，答案并非是理想的那样。</p>

<p>结果为:</p>

<ul>
  <li>当分桶数从1-500时，排序效率有所提升(其中[1,100]提升的比较明显)</li>
  <li>当分桶数大于500后，再增加分桶数，性能反而会有明显下降</li>
  <li>而且，排序时间过长，已经超过了毫秒级别</li>
  <li>所以，明显并不符合理想预期</li>
</ul>

<h4 id="详细结果">详细结果</h4>
<p>以下为在前提条件下，分桶数从10-10000变化的耗时对比</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">分桶数</th>
      <th style="text-align: center">耗时</th>
      <th style="text-align: right">趋势</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">10</td>
      <td style="text-align: center">24444ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">100</td>
      <td style="text-align: center">3246ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">500</td>
      <td style="text-align: center">3104ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">1000</td>
      <td style="text-align: center">3482ms</td>
      <td style="text-align: right">递增</td>
    </tr>
    <tr>
      <td style="text-align: left">10000</td>
      <td style="text-align: center">9185ms</td>
      <td style="text-align: right">递增</td>
    </tr>
  </tbody>
</table>

<h4 id="图示">图示</h4>
<p>其中，分桶为500时的一个排序结果图示(其中平均排序时间在2-3S，超过了理想模型下的预期时间)
<img src="https://dailc.github.io/jsPerformanceAnalysis/staticresource/performanceAnalysis/algorithmSort/demo_js_algorithmSort_bucketSort_2.png" alt="" /></p>

<p>为了探讨是桶排序自身的原因还是JS浏览器环境的局限，所以又单独在Node.js环境下和Java环境下进行分析测试</p>

<h3 id="nodejs环境下的性能数组替代链表型">Node.js环境下的性能(数组替代链表型)</h3>
<p>这种方案下采用和浏览器中一样的代码(数组替代链表型)</p>

<p>结果为:</p>

<ul>
  <li>当分桶数从1-500时，排序效率有所提升(其中[1,100]提升的比较明显)</li>
  <li>当分桶数大于500后，再增加分桶数，性能反而会有明显下降</li>
  <li>而且，排序时间过长，已经超过了毫秒级别</li>
  <li>所以，明显并不符合理想预期模型</li>
</ul>

<h4 id="详细结果-1">详细结果</h4>
<p>以下为在前提条件下，分桶数从1-1000000变化的耗时对比</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">分桶数</th>
      <th style="text-align: center">耗时</th>
      <th style="text-align: right">趋势</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: center">9964ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">10</td>
      <td style="text-align: center">1814ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">100</td>
      <td style="text-align: center">279ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">500</td>
      <td style="text-align: center">204ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">1000</td>
      <td style="text-align: center">262ms</td>
      <td style="text-align: right">递增</td>
    </tr>
    <tr>
      <td style="text-align: left">5000</td>
      <td style="text-align: center">1078ms</td>
      <td style="text-align: right">递增</td>
    </tr>
    <tr>
      <td style="text-align: left">10000</td>
      <td style="text-align: center">2171ms</td>
      <td style="text-align: right">递增</td>
    </tr>
    <tr>
      <td style="text-align: left">100000</td>
      <td style="text-align: center">9110ms</td>
      <td style="text-align: right">递增</td>
    </tr>
  </tbody>
</table>

<h3 id="nodejs环境下的性能模拟链表型">Node.js环境下的性能(模拟链表型)</h3>
<p>这种方案下采用和浏览器中一样的代码(模拟链表型)，这种方案里的主要差别是不再使用数组替代链表，而是采用模拟链表的方式</p>

<p>结果为:</p>

<ul>
  <li>整个1-100000区间，随着分桶数的增加，效率是递增的</li>
  <li>当分桶数从1-1000时，性能远远小于前面的那种数组替代链表类型</li>
  <li>当分桶数大于1000后，再增加分桶数，性能才逐渐超过前面的那种类型</li>
  <li>所以，虽然说这种算法在分桶数较低时性能很低，但是当分桶数提高时，性能有着明显的提供，而且性能和分桶数是线性关系，符合理想预期模型</li>
</ul>

<h4 id="详细结果-2">详细结果</h4>
<p>以下为在前提条件下，分桶数从1-1000000变化的耗时对比</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">分桶数</th>
      <th style="text-align: center">耗时</th>
      <th style="text-align: right">趋势</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: center">196405ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">10</td>
      <td style="text-align: center">30527ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">100</td>
      <td style="text-align: center">3029ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">500</td>
      <td style="text-align: center">976ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">1000</td>
      <td style="text-align: center">643ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">5000</td>
      <td style="text-align: center">340ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">10000</td>
      <td style="text-align: center">276ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">100000</td>
      <td style="text-align: center">312ms</td>
      <td style="text-align: right">稳定</td>
    </tr>
    <tr>
      <td style="text-align: left">1000000</td>
      <td style="text-align: center">765ms</td>
      <td style="text-align: right">递增</td>
    </tr>
  </tbody>
</table>

<h3 id="java环境下的性能">Java环境下的性能</h3>
<p>这种方案主要用来和Node.js后台执行方案的对比</p>

<p>结果为:</p>

<ul>
  <li>分桶数从小到大增加时，性能逐步增加</li>
  <li>当分桶数在10000左右时，达到性能最大值</li>
  <li>分桶数在往后增加也不会影响性能(因为实际上没有用到计算)</li>
  <li>虽然说与理想值还有一点差距，但整个结果基本符合预期</li>
</ul>

<h4 id="详细结果-3">详细结果</h4>
<p>以下为在前提条件下，分桶数从1-1000000变化的耗时对比</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">分桶数</th>
      <th style="text-align: center">耗时</th>
      <th style="text-align: right">趋势</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: center">39610ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">10</td>
      <td style="text-align: center">6094ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">100</td>
      <td style="text-align: center">1127ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">500</td>
      <td style="text-align: center">361ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">10000</td>
      <td style="text-align: center">192ms</td>
      <td style="text-align: right">递减</td>
    </tr>
    <tr>
      <td style="text-align: left">100000</td>
      <td style="text-align: center">195ms</td>
      <td style="text-align: right">稳定</td>
    </tr>
    <tr>
      <td style="text-align: left">1000000</td>
      <td style="text-align: center">198ms</td>
      <td style="text-align: right">稳定</td>
    </tr>
  </tbody>
</table>

<h3 id="总结">总结</h3>
<p>桶排序决定快慢的关键在于桶内元素的排序算法，所以不同的实现算法，相应的排序代价也是不一样的</p>

<p>比如，本文中的几个对比</p>

<ul>
  <li>使用数组模拟链表，桶内元素插入时即排序</li>
  <li>使用模拟链表，桶内元素插入时即排序</li>
</ul>

<p>以上几种的排序方案，最终的结果都是不一样的。
而且还有一点值得注意，浏览器中执行的性能损耗要远大于后端执行。</p>

<h3 id="关于js数组替代链表方案的性能疑惑">关于JS数组替代链表方案的性能疑惑</h3>
<p>最开始分析桶排序时，只采用了JS数组替代链表的方案，那时候发现当分桶数大于一定阈值时，性能会有一个明显的下降，刚开始还比较疑惑，不知道是桶排序自身的问题还是浏览器环境的限制还是算法的问题。</p>

<p>直到后来又分别在Java环境，Node.js环境进行测试，并且尝试更换算法，最终发现原来有以下原因:</p>

<ul>
  <li>浏览器中执行的性能损耗要远大于后端执行</li>
  <li>使用数组替代链表型，这个方案本身有问题</li>
  <li>另外还试过使用数组替代链表，先插入数据，全部插入完毕后再单个桶内进行快速排序，结果表明这种方案的结果与前面的数组替代链表型是基本一致的</li>
</ul>

<p>而且后来采用模拟链表方案，发现结果确实是与预期预估的趋势相符合的。</p>

<p>所以基本锁定的原因就是:<strong>JS中使用数组替代链表这种方案本身就不合理</strong></p>

<h3 id="关于如何选择桶排序方案">关于如何选择桶排序方案</h3>
<p>上述分析中可以看到，当分桶数较小时，模拟链表方案性能要远远小于数组替代链表方案，但基本上当分桶数大于1000多时，模拟链表方案的优势就体现出来了。
所以实际情况可以根据实际的需要进行选择</p>

<h2 id="示例demo">示例Demo</h2>
<p>仍然和以前的系列一样，有提供一个浏览器环境下的性能分析示例工具，参考
<a href="https://dailc.github.io/jsPerformanceAnalysis/html/performanceAnalysis/demo_performanceAnalysis_jsarraySort.html">JS几种数组排序方式分析比较</a></p>

<h2 id="原文地址">原文地址</h2>
<p>原文在我个人博客上面
<a href="https://dailc.github.io/2016/12/03/baseKnowlenge_algorithm_sort_bucketSort.html">排序算法之桶排序的深入理解以及性能分析</a></p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="http://blog.fens.me/algorithm-bucketsort-nodejs/">深入解析桶排序算法及Node.js上JavaScript的代码实现</a></li>
</ul>

					</div>
					<!-- 上一篇与下一篇-->
					<section align="right" class="post-next-prev">
					  <span>
					    <a  href="/2016/11/26/bookReview_theredandtheblack.html" class="active"  >上一篇</a>
					    &nbsp;&nbsp;&nbsp;
					    <a  href="/2016/12/04/bookReview_whitefang.html" class="active"  >下一篇</a>
					  </span>
					</section>
				</div>
				<!-- 多说-->
				
<!--多说评论 -->
<div id="duoshuo-container">
<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="http://localhost:4000/2016/12/03/baseKnowlenge_algorithm_sort_bucketSort.html}" data-title="排序算法之桶排序的深入理解以及性能分析" data-url="http://localhost:4000/2016/12/03/baseKnowlenge_algorithm_sort_bucketSort.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"dailc"};
(function() {
	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0] 
	 || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- 多说公共JS代码 end -->
</div>

				
				
			</div>
			
			<!-- 右侧包括个人介绍，TOC菜单-->
			<div class="col-md-3">
				<!-- 右侧人物面板-->
				<div class="effect1 person-card">
					
				 	<a  class="member-image">
				 			<img src="/asserts/images/img_avatar.jpg" alt="Lichun Dai"/>
				 	</a>
				 	<div class="member-info">
				 		<p class="info-name">
				 		<a >
				 			Lichun Dai
				 		</a>
				 		</p>
				 		<p>
				 			单线程生物，无法同时专注于多件事情。做自己感兴趣的工作，目前偏爱前端。业余爱好:口琴、吉他。
				 		</p>
				 	<p class="info-foot">
				 		<a class="left-card left" href="/blog/archive.html">
				 			<em>
				 				博客
				 			</em>
				 			<strong>
				 				28
				 				
				 			</strong>
				 		</a>
				 		<a class="middle-card left" href="/demo/demo.html">
				 			<em>
				 				项目
				 			</em>
				 			<strong>
				 				2
				 			</strong>
				 		</a>
				 		<a class="right-card left" href="/blog/archiveAll.html">
				 			<em>
				 				随笔
				 			</em>
				 			<strong>
				 				58
				 			</strong>
				 		</a>
				 	</p>
				 	<p class="info-social-touch">
				 		<a target="_blank" href="https://github.com/dailc" ><img src="/asserts/images/icons/favicon_github.ico" alt="GitHub"/> </a>
						<a target="_blank" href="http://5sing.kugou.com/54188866/default.html"><img src="/asserts/images/icons/favicon_5sing.ico" alt="5sing" /> </a>	
						<a target="_blank" href="http://changba.com/u/200945262"><img src="/asserts/images/icons/favicon_changba.ico" alt="唱吧" /> </a>
						<a target="_blank" href="https://www.zhihu.com/people/dailichun"><img src="/asserts/images/icons/favicon_zhihu.ico" alt="知乎" /> </a>
						<a target="_blank" href="http://www.jianshu.com/u/c104d2a4baec"><img src="/asserts/images/icons/favicon_jianshu.ico" alt="简书" /> </a>
				 	</p>
				 	</div>
				</div>

				 <!-- TOC动态菜单-->
				  <div class="slideNavContainer">     
				</div> 				
					
			</div> 
 
		</div>
	</div>
		
<script type="text/javascript" src="/asserts/js/post.js" ></script>
<script type="text/javascript" src="/asserts/js/imageBubble.js" ></script>
<script>
	ImageBubble.init('.container img');
</script>
	
	<!-- 脚步,包括版权声明，访问次数等-->
	<footer class="footer">
	    <p class="copyright">
	    	<small>
	            <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank" title="许可协议">©</a> 2016&nbsp;&nbsp;&nbsp;&nbsp;<a href="/about/">Lichun Dai</a>
	        </small>
	    </p>
	    <p class="more-tips">
	    	<span>Powered by Jekyll</span>&nbsp;&nbsp;&nbsp;&nbsp;
	    	<span id="busuanzi_container_site_pv">总访客<span id="busuanzi_value_site_uv" class="site-uv"></span>人</span>&nbsp;&nbsp;&nbsp;&nbsp;
	    	<span id="busuanzi_container_site_pv">总访问<span id="busuanzi_value_site_pv" class="site-pv"></span>次</span>
	    </p>  
	</footer>

<script>
//百度统计
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cf8506e0ef223e57ff6239944e5d46a4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<!--不蒜子 -->
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



</body>
</html>
