<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Hybrid APP基础篇(四)->JSBridge实现原理与示例 | Dailc的个人主页</title>
    <meta name="author" content="dailc" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="Everything about dailc" />
    <meta name="baidu-site-verification" content="cVrw8PsZv7" />
    <meta name="keywords" content="dailc,戴荔春,戴荔春的博客,dailc的博客" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  	<link href="/asserts/css/default.css" rel="stylesheet" type="text/css" media="all">
	<script type="text/javascript" src="/asserts/js/app.js" ></script> 
</head>
<body>
	<!--头部 -->
	<header class="header">
		<div class="header-container">
			<section class="site-logo">
				<a  href="/">撒网要见鱼</a>
			</section>
			<button class="collapsed " type="button" >
		        <span class="icon-bar"></span>
		        <span class="icon-bar"></span>
		        <span class="icon-bar"></span>
		    </button>
		    <div class="menu-container">
				<nav class="site-nav">
					<ul>
						<li>
							<a  href="/blog/archiveAll.html">随笔</a>
						</li>
						<li>
							<a  href="/blog/archive.html">博客</a>
						</li>
						<li>
							<a  href="/blog/categories.html">分类</a>
						</li>
						<li>
							<a  href="/blog/tags.html">标签</a>
						</li>
						<li>
							<a  href="/demo/demo.html">Demo</a>
						</li>
						<li>
							<a  href="/favour/music.html">音乐</a>
						</li>
						<li>
							<a  href="/favour/book.html">Book</a>
						</li>
						<li>
							<a  href="/about/timeline.html">时间轴</a>
						</li>
						<li>
							<a  href="/others/collection.html">收藏</a>
						</li>
						<li>
							<a  href="/about/about.html">关于</a>
						</li>
					</ul>
				</nav>
				<div class="site-search">
					<input type="text" />
				</div>
			</div>
		</div>
	</header>
	<link href="/asserts/css/blog_article_post.css" rel="stylesheet" type="text/css" media="all">
<link href="/asserts/css/blog_personCard_style.css" rel="stylesheet" type="text/css" media="all">
<link href="/asserts/css/imageBubble.css" rel="stylesheet" type="text/css" media="all">
	
	<div class="wrap">
		<div class="container">
			<!-- 左侧，内容，多说评论等-->
			<div class="col-md-9">
				<!-- 内容-->
				<div class="markdown-body">
					<!--标题区域 -->
					<div class="title-container">
					<h1 class="page-title"><a  title="Hybrid APP基础篇(四)->JSBridge实现原理与示例">Hybrid APP基础篇(四)->JSBridge实现原理与示例</a> </h1>
						<!-- metainfo-->
						<section class="meta clearfix">
<span class="time">
<time datetime="2016-10-04">2016-10-04</time>
</span>

| 
<span class="categories">
	分类
	    
	    <a href="/blog/categories.html#blog" title="blog">blog</a>&nbsp;
	    
</span>


| 
<span class="tags">
	标签
		
		<a href="/blog/tags.html#Hybrid" title="Hybrid">Hybrid</a>&nbsp;
		
</span>

| 
<span class="views">
	浏览
	<a id="busuanzi_value_page_pv"></a>&nbsp;
</span>
</section>
						<section class="right-tips">
							<span >
								Hybrid
							</span>
						</section>
					</div>
					<!-- 特别推荐-->
					
					<!-- 内容区域-->
					<div class="content-container">
						 <h2 id="前言">前言</h2>

<h3 id="写在前面的话">写在前面的话</h3>

<p><strong>20170223更新</strong>
将图片都附上大图路径，方便查看</p>

<p><strong>20170219更新</strong>
将稿子重新整理成MD形式了</p>

<p><strong>20161004更新</strong>
初稿发布</p>

<h3 id="前置文章">前置文章</h3>
<p>阅读本文之前，建议先阅读下列前置文章</p>

<ul>
  <li><a href="https://dailc.github.io/2016/10/04/hybridBase03NativeAndH5Interaction.html">Hybrid APP基础篇(三)-&gt;Hybrid APP之Native和H5页面交互原理</a></li>
</ul>

<h3 id="楔子">楔子</h3>
<p>上文中简单的介绍了JSBridge,以及为什么要用JSBridge,本文详细介绍它的实现原理</p>

<h2 id="原理概述">原理概述</h2>

<h3 id="简介">简介</h3>
<p>JSBridge是Native代码与JS代码的通信桥梁。目前的一种统一方案是:H5触发url scheme-&gt;Native捕获url scheme-&gt;原生分析,执行-&gt;原生调用h5。如下图</p>

<p><img src="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_1.png" alt="" /></p>

<p>查看大图 <a href="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_3.png">https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_3.png</a></p>

<h3 id="url-scheme介绍">url scheme介绍</h3>
<p>上图中有提到url scheme这个概念,那这到底是什么呢?</p>

<ul>
  <li>url scheme是一种类似于url的链接,是为了方便app直接互相调用设计的
    <ul>
      <li>具体为,可以用系统的OpenURI打开一个类似于url的链接(可拼入参数),然后系统会进行判断,如果是系统的url scheme,则打开系统应用,否则找看是否有app注册这种scheme,打开对应app</li>
      <li>需要注意的是,这种scheme必须原生app注册后才会生效,如微信的scheme为(weixin://)</li>
    </ul>
  </li>
  <li>而本文JSBridge中的url scheme则是仿照上述的形式的一种方式
    <ul>
      <li>具体为,app不会注册对应的scheme,而是由前端页面通过某种方式触发scheme(如用iframe.src),然后Native用某种方法捕获对应的url触发事件,然后拿到当前的触发url,根据定义好的协议,分析当前触发了那种方法,然后根据定义来执行等</li>
    </ul>
  </li>
  <li><strong>注意，iOS10以后，urlscheme必须符合url规范，否则会报错</strong></li>
</ul>

<h2 id="实现流程">实现流程</h2>
<p>基于上述的基本原理,现在开始设计一种JSBridge的实现</p>

<h3 id="实现思路">实现思路</h3>
<p>要实现JSBridge,我们可以进行关键步骤分析</p>

<ul>
  <li>第一步:设计出一个Native与JS交互的全局桥对象</li>
  <li>第二步:JS如何调用Native</li>
  <li>第三步:Native如何得知api被调用</li>
  <li>第四步:分析url-参数和回调的格式</li>
  <li>第五步:Native如何调用JS</li>
  <li>第六步:H5中api方法的注册以及格式</li>
</ul>

<p>如下图:
<img src="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_3.png" alt="" /></p>

<p>查看大图 <a href="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_3.png">https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_3.png</a></p>

<h3 id="第一步设计出一个native与js交互的全局桥对象">第一步:设计出一个Native与JS交互的全局桥对象</h3>
<p>我们规定,JS和Native之间的通信必须通过一个H5全局对象JSbridge来实现,该对象有如下特点</p>

<ul>
  <li>该对象名为”JSBridge”,是H5页面中全局对象window的一个属性
  <code class="highlighter-rouge">var JSBridge = window.JSBridge || (window.JSBridge = {});</code></li>
  <li>该对象有如下方法
    <ul>
      <li><code class="highlighter-rouge">registerHandler(String,Function)</code> H5调用,注册本地JS方法,注册后Native可通过JSBridge调用。调用后会将方法注册到本地变量<code class="highlighter-rouge">messageHandlers</code> 中</li>
      <li><code class="highlighter-rouge">callHandler(String,JSON,Function)</code> H5调用,调用原生开放的api,调用后实际上还是本地通过url scheme触发。调用时会将回调id存放到本地变量<code class="highlighter-rouge">responseCallbacks</code>中</li>
      <li><code class="highlighter-rouge">_handleMessageFromNative(JSON)</code> Native调用,原生调用H5页面注册的方法,或者通知H5页面执行回调方法</li>
    </ul>
  </li>
  <li>如图
    <ul>
      <li><img src="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_2.png" alt="" /></li>
    </ul>
  </li>
</ul>

<p>查看大图 <a href="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_2.png">https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_2.png</a></p>

<h3 id="第二步js如何调用native">第二步:JS如何调用Native</h3>
<p>在第一步中,我们定义好了全局桥对象,可以我们是通过它的callHandler方法来调用原生的,那么它内部经历了一个怎么样的过程呢？如下</p>

<h4 id="callhandler函数内部实现过程">callHandler函数内部实现过程</h4>
<p>在执行callHandler时,内部经历了以下步骤:</p>

<ul>
  <li>(1)判断是否有回调函数,如果有,生成一个回调函数id,并将id和对应回调添加进入回调函数集合<code class="highlighter-rouge">responseCallbacks</code>中</li>
  <li>
    <p>(2)通过特定的参数转换方法,将传入的数据,方法名一起,拼接成一个url scheme</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>//url scheme的格式如
//基本有用信息就是后面的callbackId,handlerName与data
//原生捕获到这个scheme后会进行分析
var uri = CUSTOM_PROTOCOL_SCHEME://API_Name:callbackId/handlerName?data
</code></pre>
    </div>
  </li>
  <li>
    <p>(3)使用内部早就创建好的一个隐藏iframe来触发scheme</p>

    <p>```
//创建隐藏iframe过程
var messagingIframe = document.createElement(‘iframe’);
messagingIframe.style.display = ‘none’;
document.documentElement.appendChild(messagingIframe);</p>
  </li>
</ul>

<p>//触发scheme
messagingIframe.src = uri;	
	```
	* 注意,正常来说是可以通过window.location.href达到发起网络请求的效果的，但是有一个很严重的问题，就是如果我们连续多次修改window.location.href的值，在Native层只能接收到最后一次请求，前面的请求都会被忽略掉。所以JS端发起网络请求的时候，需要使用iframe，这样就可以避免这个问题。</p>

<h3 id="第三步native如何得知api被调用">第三步:Native如何得知api被调用</h3>
<p>在上一步中,我们已经成功在H5页面中触发scheme,那么Native如何捕获scheme被触发呢？</p>

<p>根据系统不同,Android和iOS分别有自己的处理方式</p>

<h4 id="android捕获url-scheme">Android捕获url scheme</h4>
<p>在Android中(WebViewClient里),通过<code class="highlighter-rouge">shouldoverrideurlloading</code>可以捕获到url scheme的触发</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public boolean shouldOverrideUrlLoading(WebView view, String url){
	//读取到url后自行进行分析处理
	
	//如果返回false，则WebView处理链接url，如果返回true，代表WebView根据程序来执行url
	return true;
}
</code></pre>
</div>

<p>另外,Android中也可以不通过iframe.src来触发scheme,android中可以通过<code>window.prompt(uri, "");</code>来触发scheme,然后Native中通过重写WebViewClient的<code class="highlighter-rouge">onJsPrompt</code>来获取uri</p>

<h4 id="ios捕获url-scheme">iOS捕获url scheme</h4>
<p>iOS中,UIWebView有个特性：在UIWebView内发起的所有网络请求，都可以通过delegate函数在Native层得到通知。这样,我们可以在webview中捕获url scheme的触发(原理是利用 shouldStartLoadWithRequest)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {
    NSURL *url = [request URL];
     
    NSString *requestString = [[request URL] absoluteString];
    //获取利润url scheme后自行进行处理
</code></pre>
</div>

<p>之后Native捕获到了JS调用的url scheme,接下来就该到下一步分析url了</p>

<h3 id="第四步分析url-参数和回调的格式">第四步:分析url-参数和回调的格式</h3>
<p>在前面的步骤中,Native已经接收到了JS调用的方法,那么接下来,原生就应该按照定义好的数据格式来解析数据了</p>

<p>url scheme的格式,前面已经提到。Native接收到Url后,可以按照这种格式将回调参数id、api名、参数提取出来,然后按如下步骤进行</p>

<ul>
  <li>(1)根据api名,在本地找寻对应的api方法,并且记录该方法执行完后的回调函数id</li>
  <li>(2)根据提取出来的参数,根据定义好的参数进行转化
    <ul>
      <li>如果是JSON格式需要手动转换,如果是String格式直接可以使用</li>
    </ul>
  </li>
  <li>(3)原生本地执行对应的api功能方法</li>
  <li>(4)功能执行完毕后,找到这次api调用对应的回调函数id,然后连同需要传递的参数信息,组装成一个JSON格式的参数
    <ul>
      <li>回调的JSON格式为:<code class="highlighter-rouge"><span class="p">{</span><span class="err">responseId:回调id,responseData:回调数据</span><span class="p">}</span></code></li>
      <li><code class="highlighter-rouge">responseId String型</code> H5页面中对应需要执行的回调函数的id,在H5中生成url scheme时就已经产生</li>
      <li><code class="highlighter-rouge">responseData JSON型</code> Native需要传递给H5的回调数据,是一个JSON格式: <code class="highlighter-rouge"><span class="p">{</span><span class="err">code:(整型,调用是否成功,1成功,0失败),result:具体需要传递的结果信息,可以为任意类型,msg:一些其它信息,如调用错误时的错误信息</span><span class="p">}</span></code></li>
    </ul>
  </li>
  <li>(5)通过JSBridge通知H5页面回调
    <ul>
      <li>参考 <code class="highlighter-rouge">第五步Native如何调用JS</code></li>
    </ul>
  </li>
</ul>

<h3 id="第五步native如何调用js">第五步:Native如何调用JS</h3>
<p>到了这一步,就该Native通过JSBridge调用H5的JS方法或者通知H5进行回调了,具体如下</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//将回调信息传给H5
JSBridge._handleMessageFromNative(messageJSON);	
</code></pre>
</div>

<p>如上,实际上是通过JSBridge的_handleMessageFromNative传递数据给H5,其中的messageJSON数据格式根据两种不同的类型,有所区别,如下</p>

<h4 id="native通知h5页面进行回调">Native通知H5页面进行回调</h4>
<p>数据格式为:<code class="highlighter-rouge">上文中的回调的JSON格式</code></p>

<h4 id="native主动调用h5方法">Native主动调用H5方法</h4>
<p>Native主动调用H5方法时,数据格式是:<code class="highlighter-rouge"><span class="p">{</span><span class="err">handlerName:api名,data:数据,callbackId:回调id</span><span class="p">}</span></code></p>

<ul>
  <li><code class="highlighter-rouge">handlerName String型</code> 需要调用的,h5中开放的api的名称</li>
  <li><code class="highlighter-rouge">data JSON型</code> 需要传递的数据,固定为JSON格式(因为我们固定H5中注册的方法接收的第一个参数必须是JSON,第二个是回调函数)</li>
</ul>

<p>注意,这一步中,如果Native调用的api是h5没有注册的,h5页面上会有对应的错误提示。</p>

<p>另外,H5调用Native时,Native处理完毕后一定要及时通知H5进行回调,要不然这个回调函数不会自动销毁,多了后会引发内存泄漏。</p>

<h3 id="第六步h5中api方法的注册以及格式">第六步:H5中api方法的注册以及格式</h3>
<p>前面有提到Native主动调用H5中注册的api方法,那么h5中怎么注册供原生调用的api方法呢？格式又是什么呢?如下</p>

<h4 id="h5中注册供原生调用的api">H5中注册供原生调用的API</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>//注册一个测试函数
JSBridge.registerHandler('testH5Func',function(data,callback){
	alert('测试函数接收到数据:'+JSON.stringify(data));
	callback&amp;&amp;callback('测试回传数据...');
});	
</code></pre>
</div>

<p>如上述代码为注册一个供原生调用的api</p>

<h4 id="h5中注册的api格式注意">H5中注册的API格式注意</h4>
<p>如上代码,注册的api参数是<code class="highlighter-rouge">(data,callback)</code></p>

<p>其中第一个data即原生传过来的数据,第二个callback是内部封装过一次的,执行callback后会触发url scheme,通知原生获取回调信息</p>

<h2 id="进一步完善jsbridge方案">进一步完善JSBridge方案</h2>
<p>在前文中,已经完成了一套JSBridge方案,这里,在介绍下如何完善这套方案</p>

<h3 id="思路">思路</h3>
<p>github上有一个开源项目,它里面的JSBridge做法在iOS上进一步优化了,所以参考他的做法,这里进一步进行了完善。地址<a href="https://github.com/marcuswestin/WebViewJavascriptBridge">github-WebViewJavascriptBridge</a></p>

<p>大致思路就是</p>

<ul>
  <li>h5调用Native的关键步骤进行拆分,由以前的直接传递url scheme变为传递一个统一的url scheme,然后Native主动获取传递的参数
    <ul>
      <li>完善以前: H5调用Native-&gt;将所有参数组装成为url scheme-&gt;原生捕获scheme,进行分析</li>
      <li>完善以后: H5调用Native-&gt;将所有参数存入本地数组-&gt;触发一个固定的url scheme-&gt;原生捕获scheme-&gt;原生通过JSBridge主动获取参数-&gt;进行分析</li>
    </ul>
  </li>
</ul>

<h3 id="实现">实现</h3>
<p>这种完善后的流程和以前有所区别,如下</p>

<h4 id="jsbridge对象图解">JSBridge对象图解</h4>
<p><img src="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_4.png" alt="" /></p>

<p>查看大图 <a href="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_4.png">https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_4.png</a></p>

<p>####　JSBridge实现完整流程
<img src="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_5.png" alt="" /></p>

<p>查看大图 <a href="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_5.png">https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_5.png</a></p>

<h4 id="注意">注意</h4>
<p>由于这次完善的核心是:Native主动调用JS函数,并获取返回值。而在Android4.4以前,Android是没有这个功能的,所以并不完全适用于Android</p>

<p>所以一般会进行一个兼容处理,Android中采用以前的scheme传法,iOS使用完善后的方案(也便于4.4普及后后续的完善)</p>

<h2 id="完整的jsbridge">完整的JSBridge</h2>
<p>上述分析了JSBridge的实现流程,那么实际项目中,我们就应该结合上述两种,针对Android和iOS的不同情况,统一出一种完整的方案,如下</p>

<h3 id="完整调用流程图">完整调用流程图</h3>
<p><img src="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_6.png" alt="" /></p>

<p>查看大图 <a href="https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_6.png">https://dailc.github.io/staticResource/blog/hybrid/jsbridge/img_hybrid_base_jsbridgePrinciple_6.png</a></p>

<p>如上图,结合上述方案后有了一套统一JSBridge方案</p>

<h3 id="另外实现不采用url-scheme方式">另外实现:不采用url scheme方式</h3>
<p>前面提到的JSBridge都是基于url scheme的,但其实如果不考虑Android4.2以下,iOS7以下,其实也可以用另一套方案的,如下</p>

<ul>
  <li>Native调用JS的方法不变</li>
  <li>JS调用Native是不再通过触发url scheme,而是采用自带的交互,比如</li>
  <li>Android中,原生通过 addJavascriptInterface开放一个统一的api给JS调用,然后将触发url scheme步骤变为调用这个api,其余步骤不变(相当于以前是url接收参数,现在变为api函数接收参数)</li>
  <li>iOS中,原生通过JavaScriptCore里面的方法来注册一个统一api,其余和Android中一样(这里就不需要主动获取参数了,因为参数可以直接由这个函数统一接收)</li>
</ul>

<p>当然了,这只是一种可行的方案,多一种选择而已,具体实现流程请参考前面系列文章,本文不再赘述</p>

<h2 id="实现示例">实现示例</h2>

<h3 id="示例说明">示例说明</h3>
<p>本文中包括两个示例,一个是基础版本的JSBridge实现,一个是完整版本的JSBridge实现(包括JS,Android端实现等)。另外，这套方案是有iOS实践经验的，可以仿照着Android端编码(或者参考<code class="highlighter-rouge">WebViewJavascriptBridge</code>这个示例)，例子里就暂时没有提供了。</p>

<h3 id="实现源码">实现源码</h3>

<h3 id="基础版本的jsbridge">基础版本的JSBridge</h3>
<p>这里只介绍JS的实现,具体Android,iOS实现请参考完整版本,实现如下</p>

<p>由于篇幅有限，已经移步到了github上 <a href="https://github.com/dailc/hybrid_jsbridge_simple/blob/master/android/app/src/main/assets/JSbridge.js">https://github.com/dailc/hybrid_jsbridge_simple/blob/master/android/app/src/main/assets/JSbridge.js</a></p>

<h3 id="完整的实现示例">完整的实现示例</h3>
<p>请参考下述示例，有完整的Andoid原生和H5端交互的示例。</p>

<p><a href="https://github.com/dailc/hybrid_jsbridge_simple">https://github.com/dailc/hybrid_jsbridge_simple</a></p>

<h2 id="附录">附录</h2>

<h2 id="原文地址">原文地址</h2>
<p>原文在我个人博客上面
<a href="https://dailc.github.io/2016/10/04/hybridBase04JSbridgePrinciple.html">Hybrid APP基础篇(四)-&gt;JSBridge实现原理</a></p>

<h3 id="参考来源">参考来源</h3>

<ul>
  <li><a href="https://github.com/marcuswestin/WebViewJavascriptBridge">github-WebViewJavascriptBridge</a></li>
  <li><a href="http://www.jianshu.com/p/9fd80b785de1">JSBridge-Web与Native交互之iOS篇</a></li>
  <li><a href="http://blog.csdn.net/jacin1/article/details/39993935">Ios Android Hybrid app 与 Js Bridge</a></li>
  <li><a href="http://www.tuicool.com/articles/yeeABzJ">Hybrid APP架构设计思路</a></li>
  <li><a href="http://www.cnblogs.com/xesam/p/5402985.html">【Android】如何写一个JsBridge</a></li>
  <li><a href="http://blog.csdn.net/wbw1985/article/details/26264029">IOS之URL Scheme的使用</a></li>
</ul>

					</div>
					<!-- 上一篇与下一篇-->
					<section align="right" class="post-next-prev">
					  <span>
					    <a  href="/2016/10/04/hybridBase03NativeAndH5Interaction.html" class="active"  >上一篇</a>
					    &nbsp;&nbsp;&nbsp;
					    <a  href="/2016/10/28/projectManagerSharing.html" class="active"  >下一篇</a>
					  </span>
					</section>
				</div>
				<!-- 多说-->
				
<!--多说评论 -->
<div id="duoshuo-container">
<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="http://localhost:4000/2016/10/04/hybridBase04JSbridgePrinciple.html}" data-title="Hybrid APP基础篇(四)->JSBridge实现原理与示例" data-url="http://localhost:4000/2016/10/04/hybridBase04JSbridgePrinciple.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"dailc"};
(function() {
	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0] 
	 || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- 多说公共JS代码 end -->
</div>

				
				
			</div>
			
			<!-- 右侧包括个人介绍，TOC菜单-->
			<div class="col-md-3">
				<!-- 右侧人物面板-->
				<div class="effect1 person-card">
					
				 	<a  class="member-image">
				 			<img src="/asserts/images/img_avatar.jpg" alt="Lichun Dai"/>
				 	</a>
				 	<div class="member-info">
				 		<p class="info-name">
				 		<a >
				 			Lichun Dai
				 		</a>
				 		</p>
				 		<p>
				 			单线程生物，无法同时专注于多件事情。做自己感兴趣的工作，目前偏爱前端。业余爱好:口琴、吉他。
				 		</p>
				 	<p class="info-foot">
				 		<a class="left-card left" href="/blog/archive.html">
				 			<em>
				 				博客
				 			</em>
				 			<strong>
				 				28
				 				
				 			</strong>
				 		</a>
				 		<a class="middle-card left" href="/demo/demo.html">
				 			<em>
				 				项目
				 			</em>
				 			<strong>
				 				2
				 			</strong>
				 		</a>
				 		<a class="right-card left" href="/blog/archiveAll.html">
				 			<em>
				 				随笔
				 			</em>
				 			<strong>
				 				58
				 			</strong>
				 		</a>
				 	</p>
				 	<p class="info-social-touch">
				 		<a target="_blank" href="https://github.com/dailc" ><img src="/asserts/images/icons/favicon_github.ico" alt="GitHub"/> </a>
						<a target="_blank" href="http://5sing.kugou.com/54188866/default.html"><img src="/asserts/images/icons/favicon_5sing.ico" alt="5sing" /> </a>	
						<a target="_blank" href="http://changba.com/u/200945262"><img src="/asserts/images/icons/favicon_changba.ico" alt="唱吧" /> </a>
						<a target="_blank" href="https://www.zhihu.com/people/dailichun"><img src="/asserts/images/icons/favicon_zhihu.ico" alt="知乎" /> </a>
						<a target="_blank" href="http://www.jianshu.com/u/c104d2a4baec"><img src="/asserts/images/icons/favicon_jianshu.ico" alt="简书" /> </a>
				 	</p>
				 	</div>
				</div>

				 <!-- TOC动态菜单-->
				  <div class="slideNavContainer">     
				</div> 				
					
			</div> 
 
		</div>
	</div>
		
<script type="text/javascript" src="/asserts/js/post.js" ></script>
<script type="text/javascript" src="/asserts/js/imageBubble.js" ></script>
<script>
	ImageBubble.init('.container img');
</script>
	
	<!-- 脚步,包括版权声明，访问次数等-->
	<footer class="footer">
	    <p class="copyright">
	    	<small>
	            <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank" title="许可协议">©</a> 2016&nbsp;&nbsp;&nbsp;&nbsp;<a href="/about/">Lichun Dai</a>
	        </small>
	    </p>
	    <p class="more-tips">
	    	<span>Powered by Jekyll</span>&nbsp;&nbsp;&nbsp;&nbsp;
	    	<span id="busuanzi_container_site_pv">总访客<span id="busuanzi_value_site_uv" class="site-uv"></span>人</span>&nbsp;&nbsp;&nbsp;&nbsp;
	    	<span id="busuanzi_container_site_pv">总访问<span id="busuanzi_value_site_pv" class="site-pv"></span>次</span>
	    </p>  
	</footer>

<script>
//百度统计
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cf8506e0ef223e57ff6239944e5d46a4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<!--不蒜子 -->
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



</body>
</html>
